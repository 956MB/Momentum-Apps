#include <furi.h>
#include <cstring>
#include "pinball0.h"

/* generated by fbt from .png files in images folder */
#include <pinball0_icons.h>

// Gravity should be lower than 9.8 m/s^2 since the ball is on
// an angled table. We could calc this and derive the actual
// vertical vector based on the angle of the table yadda yadda yadda
#define GRAVITY           3.0f // 9.8f
#define PHYSICS_SUB_STEPS 5
#define GAME_FPS          30
#define TABLE_BUMP_AMOUNT 0.3l

#define MANUAL_MODE       true
#define MANUAL_ADJUSTMENT 20

// Sound definitions
// static const NotificationSequence ns_short_sound = {
//     &message_note_c5,
//     &message_delay_50,
//     &message_sound_off,
//     NULL,
// };

void solve(PinballState* pb, float dt) {
    Table* table = pb->table;

    float sub_dt = dt / PHYSICS_SUB_STEPS;
    for(int ss = 0; ss < PHYSICS_SUB_STEPS; ss++) {
        // apply gravity (and any other forces?)
        // FURI_LOG_I(TAG, "Applying gravity");
        if(table->balls_released) {
            float bump_amt = 1.0f;
            if(pb->keys[InputKeyUp]) {
                bump_amt = -1.04f;
            }
            for(auto& b : table->balls) {
                // We multiply GRAVITY by dt since gravity is based on seconds
                b.accelerate(Vec2(0, GRAVITY * bump_amt * sub_dt));
            }
        }

        // apply collisions (among moving objects)
        // only needed for multi-ball! - is this true? what about flippers...
        for(size_t b1 = 0; b1 < table->balls.size(); b1++) {
            for(size_t b2 = b1 + 1; b2 < table->balls.size(); b2++) {
                if(b1 != b2) {
                    auto& ball1 = table->balls[b1];
                    auto& ball2 = table->balls[b2];

                    Vec2 axis = ball1.p - ball2.p;
                    float dist2 = axis.mag2();
                    float dist = sqrtf(dist2);
                    float rr = ball1.r + ball2.r;
                    if(dist < rr) {
                        Vec2 v1 = ball1.p - ball1.prev_p;
                        Vec2 v2 = ball2.p - ball2.prev_p;

                        float factor = (dist - rr) / dist;
                        ball1.p -= axis * factor * 0.5f;
                        ball2.p -= axis * factor * 0.5f;

                        float damping = 1.01f;
                        float f1 = (damping * (axis.x * v1.x + axis.y * v1.y)) / dist2;
                        float f2 = (damping * (axis.x * v2.x + axis.y * v2.y)) / dist2;

                        v1.x += f2 * axis.x - f1 * axis.x;
                        v2.x += f1 * axis.x - f2 * axis.x;
                        v1.y += f2 * axis.y - f1 * axis.y;
                        v2.y += f1 * axis.y - f2 * axis.y;

                        ball1.prev_p = ball1.p - v1;
                        ball2.prev_p = ball2.p - v2;
                    }
                }
            }
        }

        // collisions with static objects and flippers
        for(auto& b : table->balls) {
            for(auto& o : table->objects) {
                if(o->physical && o->collide(b)) {
                    o->reset_animation();
                    continue;
                }
            }
            for(auto& f : table->flippers) {
                if(f.collide(b)) {
                    continue;
                }
            }
        }

        // update positions - of balls AND flippers
        if(table->balls_released) {
            for(auto& b : table->balls) {
                b.update(sub_dt);
            }
        }
        for(auto& f : table->flippers) {
            f.update(sub_dt);
        }
    }

    // Did any balls fall off the table?
    size_t num_in_play = table->balls.size();
    auto i = table->balls.begin();
    while(i != table->balls.end()) {
        if(i->p.y > 1280 + 100) {
            FURI_LOG_I(TAG, "ball off table!");
            i = table->balls.erase(i);
            num_in_play--;
        } else {
            ++i;
        }
    }
    if(num_in_play == 0) {
        table->balls_released = false;
        table->num_lives--;
        if(table->num_lives > 0) {
            table->balls = table->balls_initial;
        }
    }
}

void pinball_state_init(PinballState* pb) {
    furi_assert(pb);
    pb->storage = (Storage*)furi_record_open(RECORD_STORAGE);
    pb->notify = (NotificationApp*)furi_record_open(RECORD_NOTIFICATION);

    pb->table = NULL;
    pb->tick = 0;
    pb->gameStarted = false;

    pb->game_mode = GM_TableSelect;
    pb->keys[InputKeyUp] = false;
    pb->keys[InputKeyDown] = false;
    pb->keys[InputKeyRight] = false;
    pb->keys[InputKeyLeft] = false;
}

int modulo(int a, int b) {
    return (a % b + b) % b;
}

static void pinball_draw_callback(Canvas* const canvas, void* ctx) {
    furi_assert(ctx);
    PinballState* pb = (PinballState*)ctx;
    furi_mutex_acquire(pb->mutex, FuriWaitForever);

    // What are we drawing? table select / menu or the actual game?
    switch(pb->game_mode) {
    case GM_TableSelect: {
        canvas_draw_icon(canvas, 0, 0, &I_pinball0_logo); // our sweet logo
        // draw the list of table names: display it as a carousel - where the list repeats
        // and the currently selected item is always in the middle, surrounded by pinballs
        const TableList& list = pb->table_list;
        int32_t y = 25;
        size_t half_way = list.display_size / 2;

        for(size_t i = 0; i < list.display_size; i++) {
            int index =
                (list.selected - half_way + i + list.menu_items.size()) % list.menu_items.size();
            const auto& menu_item = list.menu_items[index];
            canvas_draw_str_aligned(
                canvas,
                LCD_WIDTH / 2,
                y,
                AlignCenter,
                AlignTop,
                furi_string_get_cstr(menu_item.name));
            if(i == half_way) {
                canvas_draw_disc(canvas, 8, y + 3, 2);
                canvas_draw_disc(canvas, 56, y + 3, 2);
            }
            y += 12;
        }

        pb->table->draw(canvas);
    } break;
    case GM_Playing:
        pb->table->draw(canvas);
        break;
    case GM_GameOver: {
        // pb->table->draw(canvas);
        int32_t y = 56;
        size_t interval = 40;
        float theta = (float)((pb->tick % interval) / (interval * 1.0f)) * (float)(M_PI * 2);
        FURI_LOG_I(TAG, "tick: %lu, theta: %.4f", pb->tick, (double)theta);
        // float theta_offset = (float)((pb->tick % 16) / 16.0);
        float theta_offset = 0;
        // int32_t y_offset = y + sinf(theta) * 4;
        canvas_draw_icon(canvas, 16, y + sinf(theta) * 4, &I_Arcade_G);
        canvas_draw_icon(canvas, 24, y + sinf(theta + theta_offset) * 4, &I_Arcade_A);
        canvas_draw_icon(canvas, 32, y + sinf(theta + theta_offset * 2) * 4, &I_Arcade_M);
        canvas_draw_icon(canvas, 40, y + sinf(theta + theta_offset * 3) * 4, &I_Arcade_E);

        canvas_draw_icon(canvas, 16, y + sinf(theta) * 4 + 8, &I_Arcade_O);
        canvas_draw_icon(canvas, 24, y + sinf(theta + theta_offset) * 4 + 8, &I_Arcade_V);
        canvas_draw_icon(canvas, 32, y + sinf(theta + theta_offset * 2) * 4 + 8, &I_Arcade_E);
        canvas_draw_icon(canvas, 40, y + sinf(theta + theta_offset * 3) * 4 + 8, &I_Arcade_R);
    } break;
    case GM_Error: {
        // pb->text contains error message
        canvas_draw_icon(canvas, 0, 10, &I_Arcade_E);
        canvas_draw_icon(canvas, 8, 10, &I_Arcade_R);
        canvas_draw_icon(canvas, 16, 10, &I_Arcade_R);
        canvas_draw_icon(canvas, 24, 10, &I_Arcade_O);
        canvas_draw_icon(canvas, 32, 10, &I_Arcade_R);

        int x = 10;
        int y = 30;
        // split the string on \n and display each line
        // strtok is disabled - whyyy
        char buf[256];
        strncpy(buf, pb->text, 256);
        char* str = buf;
        char* p = buf;
        bool at_end = false;
        while(str != NULL) {
            while(p && *p != '\n' && *p != '\0')
                p++;
            if(p && *p == '\0') at_end = true;
            *p = '\0';
            canvas_draw_str_aligned(canvas, x, y, AlignLeft, AlignTop, str);
            if(at_end) {
                str = NULL;
                break;
            }
            str = p + 1;
            p = str;
            y += 12;
        }

        pb->table->draw(canvas);
    } break;
    default:
        FURI_LOG_E(TAG, "Unknown Game Mode");
        break;
    }

    furi_mutex_release(pb->mutex);
}

static void pinball_input_callback(InputEvent* input_event, void* ctx) {
    furi_assert(ctx);
    FuriMessageQueue* event_queue = (FuriMessageQueue*)ctx;
    PinballEvent event = {.type = EventTypeKey, .input = *input_event};
    furi_message_queue_put(event_queue, &event, FuriWaitForever);
}

extern "C" int32_t pinball0_app(void* p) {
    UNUSED(p);

    PinballState* pinball_state = (PinballState*)malloc(sizeof(PinballState));
    pinball_state->mutex = furi_mutex_alloc(FuriMutexTypeNormal);
    if(!pinball_state->mutex) {
        FURI_LOG_E(TAG, "Cannot create mutex!");
        free(pinball_state);
        return 0;
    }

    pinball_state_init(pinball_state);

    // read the list of tables from storage
    table_table_list_init(pinball_state);

    // load the table select table
    table_load_table(pinball_state, 0);

    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(PinballEvent));
    furi_timer_set_thread_priority(FuriTimerThreadPriorityElevated);

    ViewPort* view_port = view_port_alloc();
    view_port_set_orientation(view_port, ViewPortOrientationVertical);
    view_port_draw_callback_set(view_port, pinball_draw_callback, pinball_state);
    view_port_input_callback_set(view_port, pinball_input_callback, event_queue);

    // Open the GUI and register view_port
    Gui* gui = (Gui*)furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    notification_message(pinball_state->notify, &sequence_display_backlight_enforce_on);

    // dolphin_deed(DolphinDeedPluginGameStart);

    pinball_state->processing = true;

    float dt = 0.0f;
    uint32_t last_frame_time = furi_get_tick();

    FURI_LOG_I(TAG, "Starting event loop");
    PinballEvent event;
    while(pinball_state->processing) {
        FuriStatus event_status =
            furi_message_queue_get(event_queue, &event, 10); // TODO best rate?
        furi_mutex_acquire(pinball_state->mutex, FuriWaitForever);

        if(event_status == FuriStatusOk) {
            if(event.type == EventTypeKey) {
                if(event.input.type == InputTypePress || event.input.type == InputTypeLong ||
                   event.input.type == InputTypeRepeat) {
                    switch(event.input.key) {
                    case InputKeyBack:
                        if(pinball_state->game_mode == GM_Playing ||
                           pinball_state->game_mode == GM_GameOver ||
                           pinball_state->game_mode == GM_Error) {
                            pinball_state->game_mode = GM_TableSelect;
                            table_load_table(pinball_state, TABLE_SELECT);
                        } else if(pinball_state->game_mode == GM_TableSelect) {
                            pinball_state->processing = false;
                        }
                        break;
                    case InputKeyRight:
                        pinball_state->keys[InputKeyRight] = true;
                        // temp
                        if(MANUAL_MODE && pinball_state->table->balls_released == false) {
                            pinball_state->table->balls[0].p.x += MANUAL_ADJUSTMENT;
                            pinball_state->table->balls[0].prev_p.x += MANUAL_ADJUSTMENT;
                        }
                        for(auto& f : pinball_state->table->flippers) {
                            if(f.side == Flipper::RIGHT) {
                                f.powered = true;
                            }
                        }
                        break;
                    case InputKeyLeft:
                        // FURI_LOG_I(TAG, "LEFT on");
                        pinball_state->keys[InputKeyLeft] = true;
                        // temp
                        if(MANUAL_MODE && pinball_state->table->balls_released == false) {
                            pinball_state->table->balls[0].p.x -= MANUAL_ADJUSTMENT;
                            pinball_state->table->balls[0].prev_p.x -= MANUAL_ADJUSTMENT;
                        }
                        for(auto& f : pinball_state->table->flippers) {
                            if(f.side == Flipper::LEFT) {
                                f.powered = true;
                            }
                        }
                        break;
                    case InputKeyUp: // bump table
                        if(pinball_state->game_mode == GM_Playing) {
                            if(event.input.type == InputTypePress) {
                                pinball_state->keys[InputKeyUp] = true;
                            }
                        } else if(pinball_state->game_mode == GM_TableSelect) {
                            pinball_state->table_list.selected =
                                (pinball_state->table_list.selected - 1 +
                                 pinball_state->table_list.menu_items.size()) %
                                pinball_state->table_list.menu_items.size();
                        }
                        // temp
                        if(MANUAL_MODE && pinball_state->table->balls_released == false) {
                            pinball_state->table->balls[0].p.y -= MANUAL_ADJUSTMENT;
                            pinball_state->table->balls[0].prev_p.y -= MANUAL_ADJUSTMENT;
                        }
                        break;
                    case InputKeyDown:
                        if(pinball_state->game_mode == GM_Playing) {
                            pinball_state->keys[InputKeyDown] = true;
                        } else if(pinball_state->game_mode == GM_TableSelect) {
                            pinball_state->table_list.selected =
                                (pinball_state->table_list.selected + 1) %
                                pinball_state->table_list.menu_items.size();
                        }
                        // temp
                        if(MANUAL_MODE && pinball_state->table->balls_released == false) {
                            pinball_state->table->balls[0].p.y += MANUAL_ADJUSTMENT;
                            pinball_state->table->balls[0].prev_p.y += MANUAL_ADJUSTMENT;
                        }
                        break;
                    case InputKeyOk:
                        if(pinball_state->game_mode == GM_Playing) {
                            if(!pinball_state->table->balls_released) {
                                pinball_state->gameStarted = true;
                                pinball_state->table->balls_released = true;
                            }
                        } else if(pinball_state->game_mode == GM_TableSelect) {
                            size_t sel = pinball_state->table_list.selected;
                            if(!table_load_table(pinball_state, sel + TABLE_INDEX_OFFSET)) {
                                pinball_state->game_mode = GM_Error;
                                table_load_table(pinball_state, TABLE_ERROR);
                            } else {
                                pinball_state->game_mode = GM_Playing;
                            }
                        }
                        break;
                    default:
                        break;
                    }
                } else if(event.input.type == InputTypeRelease) {
                    switch(event.input.key) {
                    case InputKeyLeft: {
                        pinball_state->keys[InputKeyLeft] = false;
                        for(auto& f : pinball_state->table->flippers) {
                            if(f.side == Flipper::LEFT) {
                                f.powered = false;
                            }
                        }
                        break;
                    }
                    case InputKeyRight: {
                        pinball_state->keys[InputKeyRight] = false;
                        for(auto& f : pinball_state->table->flippers) {
                            if(f.side == Flipper::RIGHT) {
                                f.powered = false;
                            }
                        }
                        break;
                    }
                    case InputKeyUp:
                        pinball_state->keys[InputKeyUp] = false;
                        break;
                    case InputKeyDown:
                        pinball_state->keys[InputKeyDown] = false;
                        // TODO: release plunger?
                        break;
                    default:
                        break;
                    }
                }
            }
        }
        solve(pinball_state, dt);
        for(auto& o : pinball_state->table->objects) {
            o->step_animation();
        }
        // check game state
        if(pinball_state->game_mode == GM_Playing && pinball_state->table->num_lives == 0) {
            FURI_LOG_W(TAG, "GAME OVER!");
            pinball_state->game_mode = GM_GameOver;
        }

        // no keys pressed - we should clear all input keys?
        view_port_update(view_port);
        furi_mutex_release(pinball_state->mutex);

        // game timing
        uint32_t time_lapsed = furi_get_tick() - last_frame_time;
        dt = time_lapsed / 1000.0f;
        while(dt < 1.0f / GAME_FPS) {
            time_lapsed = furi_get_tick() - last_frame_time;
            dt = time_lapsed / 1000.0f;
        }
        pinball_state->tick++;
        last_frame_time = furi_get_tick();
    }

    // general cleanup
    notification_message(pinball_state->notify, &sequence_display_backlight_enforce_auto);

    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    furi_record_close(RECORD_GUI);
    furi_record_close(RECORD_STORAGE);
    furi_record_close(RECORD_NOTIFICATION);
    view_port_free(view_port);
    furi_message_queue_free(event_queue);

    furi_mutex_free(pinball_state->mutex);

    delete pinball_state->table;
    free(pinball_state);

    furi_timer_set_thread_priority(FuriTimerThreadPriorityNormal);
    return 0;
}
